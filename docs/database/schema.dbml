Enum "account_provider" {
    "spotify"
}

Enum "user_role" {
    "admin"
    "user"
}

Enum "import_status" {
    "pending"
    "processing"
    "completed"
    "failed"
}

Enum "artist_type" {
    "person"
    "group"
    "orchestra"
    "choir"
    "character"
    "other"
}

Enum "gender" {
    "male"
    "female"
    "other"
}

Table "public"."imports" {
  "id" uuid [pk, not null]
  "user_id" uuid [not null, ref: < "public"."users"."id"]
  "filename" text [not null]
  "file_hash" text [not null]
  "file_size" integer [not null]
  "file_path" text [not null] // Path relative to uploads directory
  "status" import_status [not null, default: "pending"]
  "total_records" integer
  "imported_records" integer [default: 0]
  "failed_records" integer [default: 0]
  "error_message" jsonb
  "started_at" timestamptz
  "completed_at" timestamptz
  "created_at" timestamptz [not null]

  Indexes {
    (user_id) [name: "idx_imports_user"]
    (file_hash) [unique, name: "idx_imports_file_hash"]
    (status) [name: "idx_imports_status"]
  }
}

Table "public"."scrobbles" {
  "id" uuid [pk, not null]
  "user_id" uuid [not null, ref: < "public"."users"."id"]
  "track_id" uuid [not null, ref: < "public"."tracks"."id"]
  "album_id" uuid [ref: < "public"."albums"."id"]
  "played_at" timestamptz [not null]
  "played_duration_ms" integer [not null, default: 0]
  "skipped" boolean [not null, default: false]
  "import_id" uuid [ref: < "public"."imports"."id"]
  "provider" account_provider [not null]

  Indexes {
    (user_id, track_id, played_at) [unique, name: "no_duplicate_scrobbles"]
    (import_id) [name: "idx_scrobbles_import"]
  }
}

Table "public"."track_albums" {
  "track_id" uuid [not null, ref: < "public"."tracks"."id"]
  "album_id" uuid [not null, ref: < "public"."albums"."id"]
  "disc_number" integer
  "position" integer

  Indexes {
    (track_id, album_id) [pk, name: "track_albums_pk"]
  }
}

Table "public"."track_artists" {
  "track_id" uuid [not null, ref: < "public"."tracks"."id"]
  "artist_id" uuid [not null, ref: < "public"."artists"."id"]
  "is_primary" boolean [not null, default: true]
  "order" integer [not null]
  "join_phrase" text [not null]

  Indexes {
    (track_id, artist_id) [pk, name: "track_artists_pk"]
  }
}

Table "public"."artists" {
  "id" uuid [pk, not null]
  "name" text [not null]
  "mbid" text [unique]
  "type" artist_type // MusicBrainz artist type (Person, Group, Orchestra, etc.)
  "gender" gender // Gender (only for Person artists)
  "begin_date" text // Birth date (Person) or founding date (Group) - raw MB format
  "end_date" text // Death date (Person) or dissolution date (Group) - raw MB format
  "image_url" text
}

Table "public"."artists_groups" {
  "id" uuid [pk, not null] // Surrogate key to support multiple membership periods
  "member_id" uuid [not null, ref: < "public"."artists"."id"]
  "group_id" uuid [not null, ref: < "public"."artists"."id"]
  "begin_date" date // Normalized start date (from MusicBrainz)
  "end_date" date // Normalized end date, null if still active
  "begin_raw" text // Raw MB date string (YYYY, YYYY-MM, or YYYY-MM-DD)
  "end_raw" text // Raw MB date string
  "ended" boolean [not null, default: false] // Whether membership has ended
  Indexes {
    (member_id) [name: "idx_artists_groups_member"]
    (group_id) [name: "idx_artists_groups_group"]
    (member_id, group_id, begin_raw, end_raw) [unique, name: "idx_artists_groups_unique_period"]
  }
}

Table "public"."users" {
  "id" uuid [pk, not null]
  "email" text [unique, not null]
  "username" text [unique]
  "image_url" text
  "role" user_role [not null]
  "created_at" timestamptz [not null]
}

Table "public"."tracks" {
  "id" uuid [pk, not null]
  "title" text [not null]
  "duration_ms" integer
  "mbid" text [unique]
  "isrc" text [unique]
  "explicit" boolean [not null]
}

Table "public"."accounts" {
  "id" uuid [pk, not null]
  "user_id" uuid [not null, ref: < "public"."users"."id"]
  "provider" account_provider [not null]
  "external_id" text [unique, not null]
  "access_token" text
  "refresh_token" text
  "expires_in" integer
  "scope" text
}

Table "public"."albums" {
  "id" uuid [pk, not null]
  "artist_id" uuid [not null, ref: < "public"."artists"."id"]
  "title" text [not null]
  "release_date" date
  "image_url" text
  "mbid" text [unique]
}
